(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{222:function(e,t,a){"use strict";a.r(t);var s=a(6),r=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"runtime"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#runtime"}},[e._v("#")]),e._v(" Runtime")]),e._v(" "),a("p",[e._v("AssemblyScript's runtime takes care of all the ins and outs of memory management and garbage collection, yet the compiler lets a developer choose the ideal runtime variant for their use case.")]),e._v(" "),a("h2",{attrs:{id:"variants"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#variants"}},[e._v("#")]),e._v(" Variants")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"left"}},[e._v("Variant")]),e._v(" "),a("th",{staticStyle:{"text-align":"left"}},[e._v("Description")])])]),e._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"left"}},[e._v("full")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("A proper memory manager and reference-counting based garbage collector, with runtime interfaces being exported to the host for being able to create managed objects externally.")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[e._v("half")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("The same as "),a("code",[e._v("full")]),e._v(" but without any exports, i.e. where creating objects externally is not required. This allows the optimizer to eliminate parts of the runtime that are not needed.")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[e._v("stub")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("A minimalist arena memory manager without any means of freeing up memory again, but the same external interface as "),a("code",[e._v("full")]),e._v(". Useful for very short-lived programs or programs with hardly any memory footprint, while keeping the option to switch to "),a("code",[e._v("full")]),e._v(" without any further changes. No garbage collection.")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[e._v("none")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("The same as "),a("code",[e._v("stub")]),e._v(" but without any exports, for the same reasons as explained in "),a("code",[e._v("half")]),e._v(". Essentially evaporates entirely after optimizations.")])])])]),e._v(" "),a("p",[e._v("The default runtime included in a program is the "),a("code",[e._v("full")]),e._v(" runtime, but deciding for another variant using the "),a("code",[e._v("--runtime")]),e._v(" option can help to reduce binary size significantly. The "),a("code",[e._v("full")]),e._v(" runtime adds about 2KB of additional optimized code to your module, which is not that much considering what it brings to the table, but might still be overkill for simple programs.")]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),a("p",[e._v("Previous versions of the compiler (pre 0.7) did not include any runtime functionality by default but instead required "),a("code",[e._v("import")]),e._v("ing an allocator and potentially an experimental tracing collector. This is not supported anymore by recent versions of the compiler.")])]),e._v(" "),a("h2",{attrs:{id:"interface"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#interface"}},[e._v("#")]),e._v(" Interface")]),e._v(" "),a("p",[e._v("The following paragraphs are relevant in low-level code respectively when working with objects externally only. In normal high-level code, the compiler utilizes these mechanisms automatically.")]),e._v(" "),a("h3",{attrs:{id:"allocating-managed-objects"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#allocating-managed-objects"}},[e._v("#")]),e._v(" Allocating managed objects")]),e._v(" "),a("p",[e._v("When allocating a managed object, it is necessary to also provide its unique class id so the runtime can properly recognize it. The unique id of any managed type can be obtained via "),a("code",[e._v("idof<TheType>()")]),e._v(". Each concrete class (like "),a("code",[e._v("String")]),e._v(", "),a("code",[e._v("Array<i32>")]),e._v(", "),a("code",[e._v("Array<f32>")]),e._v(") has its own id. The ids of ArrayBuffer (id=0), String (id=1) and ArrayBufferView (id=2) are always the same, while all other ids are generated sequentially on first use of a class and differ between modules. Hence, it is usually necessary to "),a("code",[e._v("export Uint8Array_ID = idof<Uint8Array>()")]),e._v(" for example when allocating one externally. The relevant interface is:")]),e._v(" "),a("ul",[a("li",[a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("function")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("__alloc")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[e._v("size"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("usize")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" id"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("u32")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("usize")]),e._v("\n")])])]),e._v("Dynamically allocates a chunk of memory for an object represented by the specified id of at least the given size in bytes and returns its address. Alignment is guaranteed to be 16 bytes to fit up to v128 values naturally. Does not zero memory.")])]),e._v(" "),a("p",[e._v("The "),a("RouterLink",{attrs:{to:"/basics/loader.html"}},[e._v("loader")]),e._v(" provides some additional functionality for convenience, like "),a("code",[e._v("__allocString")]),e._v(".")],1),e._v(" "),a("h3",{attrs:{id:"managing-lifetimes"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#managing-lifetimes"}},[e._v("#")]),e._v(" Managing lifetimes")]),e._v(" "),a("p",[e._v("The concept is simple: If a reference to an object is established, the reference count of the object is increased by 1 (a reference is retained), and when a reference to an object is deleted, the reference count of the object is decreased by 1 (a reference is released). If the reference count of an object reaches 0, it is considered for collection and its memory ultimately returned to the memory manager for reuse. The relevant interface is:")]),e._v(" "),a("ul",[a("li",[a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("function")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("__retain")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[e._v("ptr"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("usize")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("usize")]),e._v("\n")])])]),a("p",[e._v("Retains a reference to the object pointed to by "),a("code",[e._v("ptr")]),e._v(". The object doesn't become collected as long as there's at least one retained reference to it. Returns the pointer.")])]),e._v(" "),a("li",[a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("function")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("__release")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[e._v("ptr"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("usize")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("void")]),e._v("\n")])])]),a("p",[e._v("Releases a reference to the object pointer to by "),a("code",[e._v("ptr")]),e._v(". The object is considered for collection once all references to it have been released.")])])]),e._v(" "),a("p",[e._v("The compiler inserts retain and release calls automatically and this is opaque to a user on a higher level. On a lower level, for instance when dealing with managed objects externally, it is necessary to understand and adhere to the rules the compiler applies.")]),e._v(" "),a("p",[e._v('{% hint style="info" %}\nTechnically, both '),a("code",[e._v("__retain")]),e._v(" and "),a("code",[e._v("__release")]),e._v(" are nops when using the "),a("code",[e._v("stub")]),e._v("runtime, so one can either decide to skip the following for good or spend a little extra time to account for the possibility of upgrading to "),a("code",[e._v("full")]),e._v(" later on.\n{% endhint %}")]),e._v(" "),a("h4",{attrs:{id:"rules"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rules"}},[e._v("#")]),e._v(" Rules")]),e._v(" "),a("ol",[a("li",[e._v("A reference to an object "),a("strong",[e._v("is retained")]),e._v(" when assigning it to a target (local, global, field or otherwise inserting it into a structure) of a reference type, with the exceptions stated in (3).")]),e._v(" "),a("li",[e._v("A reference to an object "),a("strong",[e._v("is released")]),e._v(" when assigning another object to a target of a reference type previously retaining a reference to it, or if the lifetime of the local or structure currently retaining a reference to an object ends.")]),e._v(" "),a("li",[e._v("A reference to an object "),a("strong",[e._v("is not released")]),e._v(" but "),a("strong",[e._v("remains retained")]),e._v(" when returning a reference typed object from a call (function, getter, constructor or operator overload). Instead, the caller is expected to perform the release. This also means:\n"),a("ul",[a("li",[e._v("If a reference to the object "),a("strong",[e._v("would be immediately retained")]),e._v(" by assigning the object to a target of a reference type, the compiler will not retain it twice, but skip retaining it on assignment.")]),e._v(" "),a("li",[e._v("If a reference to the object "),a("strong",[e._v("will not be immediately retained")]),e._v(", the compiler will insert a temporary local into the current scope that autoreleases the reference to the object at the end of the scope.")])])])]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),a("p",[e._v("Objects created by calling "),a("code",[e._v("__alloc")]),e._v(" start with a reference count of 0. This is not the case for constructors, these behave like calls. Built-ins like "),a("code",[e._v("store<T>")]),e._v(" emit instructions directly and don't behave like calls.")])]),e._v(" "),a("h3",{attrs:{id:"working-with-references-externally"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#working-with-references-externally"}},[e._v("#")]),e._v(" Working with references externally")]),e._v(" "),a("p",[e._v("Working with objects through imports and exports, like when using "),a("RouterLink",{attrs:{to:"/loader.html"}},[e._v("the loader")]),e._v(", is "),a("em",[e._v("relatively")]),e._v(" straight-forward. However, if not handled properly, the program will either leak memory, free objects prematurely or even break. So here's some advice:")],1),e._v(" "),a("ul",[a("li",[e._v("Always "),a("code",[e._v("__retain")]),e._v(" a reference to manually "),a("code",[e._v("__alloc")]),e._v("'ed objects and "),a("code",[e._v("__release")]),e._v(" the reference again when done with the object.")]),e._v(" "),a("li",[e._v("Always "),a("code",[e._v("__release")]),e._v(" the reference to an object that was a return value of a call (see above) when done with it. It is not necessary to "),a("code",[e._v("__retain")]),e._v(" a reference to returned objects.")]),e._v(" "),a("li",[e._v("Always "),a("code",[e._v("__retain")]),e._v(" a reference to an object read from memory, and "),a("code",[e._v("__release")]),e._v(" the reference again when done with the object.")])]),e._v(" "),a("h3",{attrs:{id:"working-with-references-internally"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#working-with-references-internally"}},[e._v("#")]),e._v(" Working with references internally")]),e._v(" "),a("p",[e._v("Working with objects internally, like when creating custom standard library components or otherwise writing low-level code, requires special care because switching between pointers and reference types can become quite tricky. The internal interface also provides "),a("a",{attrs:{href:"https://github.com/AssemblyScript/assemblyscript/tree/master/std/assembly/rt",target:"_blank",rel:"noopener noreferrer"}},[e._v("additional utility"),a("OutboundLink")],1),e._v(" that is only relevant in very specific cases.")]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),a("p",[e._v("One common point of confusion here is that the rules above "),a("strong",[e._v("operate on types, not values")]),e._v(". Means: If the target is of a reference-type, the rules apply, but if the target is of an "),a("code",[e._v("usize")]),e._v(" type, the rules do not apply, even if the value is a "),a("code",[e._v("changetype<usize>(..)")]),e._v("'d object.")])]),e._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("let")]),e._v(" ref "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("new")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("ArrayBuffer")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("10")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// retains (reference type)")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("let")]),e._v(" buf "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" changetype"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("usize")]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("ref"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// does not retain (usize)")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("...")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// compiler will automatically __release(ref)")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("let")]),e._v(" buf "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" changetype"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("usize")]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("new")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("ArrayBuffer")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("10")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// does not retain (usize)")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// inserts a temporary, because _the object_ is not immediately assigned")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("...")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// compiler will automatically __release(theTemp)")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("let")]),e._v(" ref "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" changetype"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("ArrayBuffer")]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("__alloc")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("10")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" idof"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("ArrayBuffer")]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// retains on ref, because after changetype an object is assigned")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("...")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// compiler will automatically __release(ref)")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("h3",{attrs:{id:"collecting-garbage"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#collecting-garbage"}},[e._v("#")]),e._v(" Collecting garbage")]),e._v(" "),a("p",[e._v("By default, the full and half runtime will automatically try to collect cyclic garbage when memory must be grown. This behavior can be disabled by setting "),a("code",[e._v("gc.auto = false")]),e._v(" in performance critical code. Likewise, if there is a good opportunity to collect cyclic garbage at a given point in time, like if the application is idle, "),a("code",[e._v("gc.collect()")]),e._v(" can be called to force a full garbage collection cycle. Protip: If no cyclic structures are used, no garbage must be collected.")]),e._v(" "),a("h2",{attrs:{id:"future-options"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#future-options"}},[e._v("#")]),e._v(" Future options")]),e._v(" "),a("p",[e._v("The reason for implementing our own runtime is that "),a("a",{attrs:{href:"https://github.com/WebAssembly/gc",target:"_blank",rel:"noopener noreferrer"}},[e._v("WebAssembly GC"),a("OutboundLink")],1),e._v(" is still in the works without any ETA on it, unfortunately. So we decided to roll our own for the time being, but as soon as WebAssembly GC lands, it is likely that we are going to reconsider alternatives.")]),e._v(" "),a("h2",{attrs:{id:"implementation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#implementation"}},[e._v("#")]),e._v(" Implementation")]),e._v(" "),a("p",[e._v("The memory manager used by AssemblyScript is a variant of TLSF ("),a("a",{attrs:{href:"http://www.gii.upv.es/tlsf/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Two-Level Segregate Fit memory allocator"),a("OutboundLink")],1),e._v(") and it is accompanied by PureRC (a variant of "),a("a",{attrs:{href:"https://researcher.watson.ibm.com/researcher/files/us-bacon/Bacon03Pure.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("A Pure Reference Counting Garbage Collector"),a("OutboundLink")],1),e._v(") with "),a("a",{attrs:{href:"https://github.com/dcodeIO/purerc",target:"_blank",rel:"noopener noreferrer"}},[e._v("slight modifications of assumptions"),a("OutboundLink")],1),e._v(" to avoid unnecessary work. Essentially, TLSF is responsible for partitioning "),a("RouterLink",{attrs:{to:"/memory.html#dynamic-memory"}},[e._v("dynamic memory")]),e._v(" into chunks that can be used by the various objects, while PureRC keeps track of their lifetimes.")],1),e._v(" "),a("h2",{attrs:{id:"performance-considerations"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#performance-considerations"}},[e._v("#")]),e._v(" Performance considerations")]),e._v(" "),a("p",[e._v("Both the TLSF memory manager and the concept of reference counting are a good fit for "),a("em",[e._v("predictable performance")]),e._v(" scenarios. Remember: WebAssembly is about exactly that. It is not necessarily the fastest choice in every possible scenario, though.")]),e._v(" "),a("p",[e._v("It is also likely that our implementations are not as optimized yet as ultimately possible. If you are smarter than us, please let us know of your thoughts and findings.")]),e._v(" "),a("h2",{attrs:{id:"internals"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#internals"}},[e._v("#")]),e._v(" Internals")]),e._v(" "),a("p",[e._v("If you are interested in the inner workings, the internal APIs are explained in "),a("a",{attrs:{href:"https://github.com/AssemblyScript/assemblyscript/tree/master/std/assembly/rt",target:"_blank",rel:"noopener noreferrer"}},[e._v("the runtime's README file"),a("OutboundLink")],1),e._v(" and of course in its sources - feel free to take a look!")]),e._v(" "),a("h4",{attrs:{id:"runtime-type-information-rtti"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#runtime-type-information-rtti"}},[e._v("#")]),e._v(" Runtime type information (RTTI)")]),e._v(" "),a("p",[e._v("Every module using managed objects contains a memory segment with basic type information, that "),a("RouterLink",{attrs:{to:"/loader.html"}},[e._v("the loader")]),e._v(" for example uses when allocating new arrays. Internally, RTTI is used to perform dynamic "),a("code",[e._v("instanceof")]),e._v(" checks and to determine whether a class is inherently acyclic. The memory offset of RTTI can be obtained by reading the "),a("code",[e._v("__rtti_base")]),e._v(" global. Essentially, the compiler maps every concrete class to a unique id, starting with 0 (=ArrayBuffer), 1 (=String) and 2 (=ArrayBufferView) . For each such class, the compiler remembers the id of the respective base class, if any, and a set of flags describing the class. Flags for example contain information about key and value alignments, whether a class is managed and so on. Structure is like this:")],1),e._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"left"}},[e._v("Name")]),e._v(" "),a("th",{staticStyle:{"text-align":"right"}},[e._v("Offset")]),e._v(" "),a("th",{staticStyle:{"text-align":"left"}},[e._v("Type")]),e._v(" "),a("th",{staticStyle:{"text-align":"left"}},[e._v("Description")])])]),e._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"left"}},[e._v("#count")]),e._v(" "),a("td",{staticStyle:{"text-align":"right"}},[e._v("0")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("u32")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("Number of concrete classes")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[e._v("#flags[0]")]),e._v(" "),a("td",{staticStyle:{"text-align":"right"}},[e._v("4")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("u32")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("Flags describing the class with id=0")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[e._v("#base[0]")]),e._v(" "),a("td",{staticStyle:{"text-align":"right"}},[e._v("8")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("u32")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("Base class id of the class with id=0")])]),e._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[e._v("#flags[1]")]),e._v(" "),a("td",{staticStyle:{"text-align":"right"}},[e._v("12")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("u32")]),e._v(" "),a("td",{staticStyle:{"text-align":"left"}},[e._v("... etc. ...")])])])]),e._v(" "),a("p",[e._v("Flag values are currently still in flux, but if you are interested in these, feel free to take a look at the sources.")]),e._v(" "),a("h4",{attrs:{id:"notes"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#notes"}},[e._v("#")]),e._v(" Notes")]),e._v(" "),a("p",[e._v("Unlike other reference counting implementions, allocating an object starts with a reference count of 0. This is useful in standard library code where memory is first allocated and then assigned to a variable, establishing the first reference.")]),e._v(" "),a("p",[e._v("The compiler does some extra work to evaluate whether an object can potentially become part of a reference cycle. Any object that cannot directly or indirectly reference another object of its kind is considered "),a("em",[e._v("inherently acyclic")]),e._v(", so it does not have to be added to the cycle buffer for further evaluation by deferred garbage collection.")]),e._v(" "),a("p",[e._v("Due to the lack of random access to WebAssembly's execution stack (remember: AssemblyScript does not have a stack on its own), values returned from a function become pre-retained for the caller, expecting that it will release the reference at the end, or give the reference to its own caller. This also leads to situations where sometimes a reference must be retained on assignment, and sometimes it must not. It also leads to situations where two branches must be unified, for example if there is a pre-retained value in one arm and one that is not in the other. The compiler is taking care of these situations, but it also requires special care when dealing with the reference counting internals within the standard library.")]),e._v(" "),a("p",[e._v("The compiler also utilizes a concept of so called autorelease locals. Essentially, if a reference enters a block of code from somewhere else, is pre-retained but not immediately assigned, such a local is added to the current scope to postpone the necessary release until the scope is exited.")]),e._v(" "),a("p",[e._v("One thing not particularly ideal at this point is that each function is expected to retain the reference-type arguments it is given, and release them again at the end. This is necessary because the compiler does just a single pass and doesn't know whether a variable becomes reassigned beforehand (no SSA or similar, that's left to Binaryen in an attempt to avoid duplicating its code). It does already skip this for certain variables like "),a("code",[e._v("this")]),e._v(" that cannot be reassigned, but there are definitely more optimization opportunities along the way. Due to AssemblyScript essentially being a compiler on top of another compiler, it is somewhat unclear however where to perform such optimizations.")])])}),[],!1,null,null,null);t.default=r.exports}}]);